####  首页加载性能优化

![75489852262](C:\Users\zxh\Desktop\前端\前端面试八股\项目亮点.assets\1754898522622.png)

![75489865808](C:\Users\zxh\Desktop\前端\前端面试八股\项目亮点.assets\1754898658088.png)

数据交互的安全性

**二次封装axios**

  ![75489956075](C:\Users\zxh\Desktop\前端\前端面试八股\项目亮点.assets\1754899560753.png)

 为了不每次都引入，就做一些处理

![75490049611](C:\Users\zxh\Desktop\前端\前端面试八股\项目亮点.assets\1754900496110.png)

```javascript
import axios form "axios";
const serive=axios.create({
    baseURL:"http://localhost:8000",
})
serive.interceptors.request.use(
    function(config){
        if(config.url !== "/login"){
            config.headers["Authorization"]=`Bearer ${localStorage.getItem("token")}`;
        }
        return config;
    }
    funcion(err){
    return Promis.reject(err)
};
//响应拦截器


service.interceptors.response.use(
  function (response) {
    // 对响应数据做点什么
    // return response;
    if (response.data.code === 0) {
      response.data.data.token &&
        localStorage.setItem("token", response.data.data.token);
      response.data.data.refresh_token &&
        localStorage.setItem("refresh_token", response.data.data.refresh_token);
      return response.data.data;
    } else if (response.data.code === 401) {
      // 将
      // 重新请求 为了拿到新的短token 刷新token的接口 携带长token 过去
      // ElMessage.error("token失效");
      // return false;

      getRefresh().then((res) => {
        console.log(res);
      });
    }
  },
  function (error) {
    // 记得在这里重新设置token，再发一次请求
    
    else if (response.data.code === 401) {
      // 将
      // 重新请求 为了拿到新的短token 刷新token的接口 携带长token 过去
      // ElMessage.error("token失效");
      // return false;

      let result = await.getRefresh().then((res) => {
        return res;
      });
    }
    if (result) {
      // 继续发送这个请求
      response.config.headers.Authorization = 'Bearer ${localStorage.getItem("token")'';
      const re = await service.request(response.config);
      console.log(re);
    }
  }
);
)


//处理一下
function request(options){
    options.method=options.method||"get";
    if(options.methos.toLowerCase()==="get"){
        options.params=options.data
    }
    return service(options)
}
export default request;

//长tiken刷新短token的接口
export const getRefresh = ()=>{
    return request({
        url:"/refresh_token",
        methos:"get"
    })
}
```



处理get请求的问题

然后用这个去做一些提前的配置

**token无感刷新**

复杂的场景，就是做一些动作的时候，突然token失效了，跳转到登录页面

![75490109644](C:\Users\zxh\Desktop\前端\前端面试八股\项目亮点.assets\1754901096441.png)

长短token来实现

![75490159371](C:\Users\zxh\Desktop\前端\前端面试八股\项目亮点.assets\1754901593711.png)

根据长token拿到新短token

![75490164407](C:\Users\zxh\Desktop\前端\前端面试八股\项目亮点.assets\1754901644073.png)

记得在这里重新设置token，再发一次请求

![75490231241](C:\Users\zxh\Desktop\前端\前端面试八股\项目亮点.assets\1754902312418.png)

直播把那个拦截器的拦截的东西再发一遍，最后记得retrun re





####   首屏优化

 不是所有的项目都要弄优化

优化不揍:

1. 计算首屏加载时间,使用开发者工具可以看到,这个就是你的指标了

2.  使用PerformanceObserver来调用这个

3. ![75490516998](C:\Users\zxh\Desktop\前端\前端面试八股\项目亮点.assets\1754905169983.png)

   相关的调用代码

   一个适合老浏览器,一个适合新浏览器并且精准一点

4. 页面优化更倾向于移动端,手机容易网速慢

5. 首屏加载是加载前的白色，针对大文件的优化




方法：

- 针对一些大组件使用异步组件的方法

  ```javascript
  defineAsyncComponent(()=>{
      return import('./cs.vue')
  })
  ```

  这个组件是vue提供出来的,只有使用到该组件才会从后端发送过来

- 针对图片的优化

  把base64的图片资源换成网络资源的图片

  这样的图片资源不会影响到首屏时间

  网络图片会有一个缺省图在没有返回的时候,加载完也会偷偷返回

- 骨架屏

  这个不是组件的骨架屏

  这个东西要写在<div id=app></div>里面

  ![75496281468](C:\Users\zxh\Desktop\前端\前端面试八股\项目亮点.assets\1754962814684.png)






####  二次封装进阶

![75496823505](C:\Users\zxh\Desktop\前端\前端面试八股\项目亮点.assets\1754968235051.png)

1. 项目环境分析

   检测开发，测试，线上

   使用一个js文件检测环境

   ```javascript
   //三种环境检测

   ```

   ![75496480622](C:\Users\zxh\Desktop\前端\前端面试八股\项目亮点.assets\1754964806225.png)

   记得导出这个文件的吗,模块

   export default {

   env,

   ...EnvConfig[env]

   }

   在你封装的axios里面使用

   ![75496500260](C:\Users\zxh\Desktop\前端\前端面试八股\项目亮点.assets\1754965002600.png)

   这样这个基础url就能根据不同的环境配置不同的url了

   还有一个就是根据不同的请求配置不一样的参数什么的

   ![75496753390](C:\Users\zxh\Desktop\前端\前端面试八股\项目亮点.assets\1754967533904.png)

   ​

   链式调用的支持

   ![75496809468](C:\Users\zxh\Desktop\前端\前端面试八股\项目亮点.assets\1754968094684.png)

   这样就可以通过

   return request.get("/sss/sss")来调用request

   给每个方法创建一个快捷函数





####  大数据渲染

![75496833827](C:\Users\zxh\Desktop\前端\前端面试八股\项目亮点.assets\1754968338276.png)

虚拟列表和分批处理

![75509533018](C:\Users\zxh\Desktop\前端\前端面试八股\项目亮点.assets\1755095330182.png)

1. 虚拟列表

    

