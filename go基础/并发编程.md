#  Go并发编程入门

Go语言之所以被称为现代化的编程语言，就是因为它在语言层面已经内置了调度和上下文切换的机制。Go语言的并发编程特点主要体现在Goroutine协程和Channel通道的使用上。



####  父子协程

当父协程创建一个子协程时，父协程和子协程是相互独立的并发执行单元。父协程可以继续执行其他操作，而不需要等待子协程完成。子协程会在创建后立即开始执行，与父协程并发执行。父协程和子协程之间不存在直接的调用关系，它们是相互独立的执行流程。父协程的结束不会影响子协程的执行。

在使用协程进行并发编程时，我们需要确保主协程不会过早地结束，以确保子协程能够完成任务，可以考虑采用以下方法：

1. 使用time.Sleep使协程睡眠确保并发子协程完成

   ```go
   package main
   import (
   	"fmt"
   	"sync"
   )
   func main() {
   	var wg sync.WaitGroup
   	wg.Add(2) // 设置等待组的计数器为2，表示有两个协程需要等待
   	go func() {//开启协程1
   		defer wg.Done() // 协程完成后调用Done方法，减少等待组的计数器
   		task("Task 1") 
   	}()
   	go func() {//开启协程1
   		defer wg.Done() // 协程完成后调用Done方法，减少等待组的计数器
   		task("Task 2") 
   	}()
   	wg.Wait() // 等待所有协程完成，完成后才结束main协程
   }
   func task(name string) {
   	for i := 0; i < 5; i++ {
   		fmt.Println(name+":", i) // 打印任务名称和当前迭代值
   	}
   }

   ```

2. 使用sync.WaitGroup等待组确保并发子协程完成

   ```go
   package main
   import (
   	"fmt"
   	"sync"
   )
   func main() {
   	var wg sync.WaitGroup
   	wg.Add(2) // 设置等待组的计数器为2，表示有两个协程需要等待
   	go func() {//开启协程1
   		defer wg.Done() // 协程完成后调用Done方法，减少等待组的计数器
   		task("Task 1") 
   	}()
   	go func() {//开启协程1
   		defer wg.Done() // 协程完成后调用Done方法，减少等待组的计数器
   		task("Task 2") 
   	}()
   	wg.Wait() // 等待所有协程完成，完成后才结束main协程
   }
   func task(name string) {
   	for i := 0; i < 5; i++ {
   		fmt.Println(name+":", i) // 打印任务名称和当前迭代值
   	}
   }


   ```

- channel实现通讯

  在并发编程中，单纯地将函数并发执行是没有意义的。函数与函数间需要交换数据才能体现并发执行函数的意义

> CSP（Communicating sequential processes）是一种并发编程模型，它强调通过通信来实现并发

```go
package main
import "fmt"
func main() {
	ch := make(chan int) // 创建一个int类型的通道

	go func() {
		ch <- 10 // 发送数据到通道
	}()

	data := <-ch // 从通道接收数据
	fmt.Println(data)
}

```

在上述示例中，我们通过make函数创建了一个无缓冲的int类型的通道ch，无缓冲的通道只有在有人接收值的时候才能发送值。就。因此，在匿名函数中使用`ch <- 10`将数据10发送到通道，就必须还要通过`data := <-ch`从通道中接收数据并打印。



- select多路复用

  - select可以同时监听一个或多个channel，直到其中一个channel ready
  - 如果多个channel同时ready，则随机选择一个执行
  - 可以用于判断管道是否存满

  ```go
   // 创建两个缓冲区大小为 1 的通道
      ch1 := make(chan int, 1)
      ch2 make(chan int, 1)
      // 向 ch1 发送数据的 goroutine
      go func() {
          time.Sleep(2 * time.Second)
          ch1 <- 1
      }()
      // 向 ch2 发送数据的 goroutine
      go func() {
          time.Sleep(1 * time.Second)
          ch2 <- 2
      }()
      // 无限循环，等待从通道接收数据
      for {
          select {
          case x := <-ch1:
              fmt.Println("Received from ch1:", x)
              return
          case x := <-ch2:
              fmt.Println("Received from ch2:", x)
              return
          default:
              // 如果两个通道都已满，则打印一条消息并等待 500 毫秒
              fmt.Println("All channels are full")
              time.Sleep(500 * time.Millisecond)
              break
          }
      }
  ```



####  并发安全

1. 使用互斥锁（Mutex）：互斥锁是一种最基本的同步原语，它可以保证同一时刻只有一个 goroutine 可以访问共享资源在访问共享资源之前，需要先获取互斥锁，访问完成后再释放互斥锁。这样可以避免多个 goroutine 同访问共享资源导致的数据竞争问题。
2. 使用读写锁（RWMutex）：读写锁是一种特殊的互斥锁它可以同时支持多个 goroutine 对共享资源进行读操作，但只能有一个 goroutine 进行写操作。在读写锁中，读操作和写操作是互斥的，但多个读操作间是不互斥的。这样可以提高并发性能，减少锁的竞争。
3. 使用原子操作（Atomic）：原子操作是一种特殊的操作它可以保证在多个 goroutine 同时访问同一个变量时，对该变量的读写操作是原子的。原子操作可以避免数据竞争问题，但只适用于简单的数据类型，如整数、指针等。
4. 使用通道（Channel）：通道是一种特殊数据结构，它可以在多个 goroutine 之间传递数据，并且保证传递的数据是并发安全的。在使用通道时需要注意通道的缓冲区大小和通道的方向，以避免死锁和数据竞争问题。
5. 使用 sync 包中的其他同步原语：Go语言的标准库中提供了许多同步原语，如条件变（Cond）、信号量（Semaphore）等，可以根据具体的需求选择合适的同步原语来实现并发安全。

