# go文档分析

- **go doc**

  Go提供了两种查看文档的方式，一种是使用`go doc`命令在终端查看，这种适用于使用VIM等工具在终端开发的人员，它们不用离开终端，既可以查看想查看的文档，又可以编码。

  第二种方式，是使用浏览器查看的方式，通过`godoc`命令可以在本机启动一个web服务，我们可以通过打开浏览器，访问这个服务来查看我们的Go文档。

- **数组**

  1. 内部实现：数组是长度固定的数据类型，必须储存一段相同类型的元素，而且这些元素是连续的

  2. 声明和初始化：

     1. 指明存储数据的类型
     2. 存储元素的数量，数组长度

     ```go
     var array [5]int
     //声明，形成五个0的数组
     array:=[5]int{1,2,3,4,5}
     //再初始化
     array:=[...]int{1,2,3,4,5}
     //不限制数组长度
     array;=[5]int{1:3,3:5}
     //只初始化索引1和3的值
     ```

  3. 使用数组：

     ```go
     array[1]=3
     //修改元素
     func main() {
         array := [5]int{1: 1, 3: 4}    
         for i, v := range array {
             fmt.Printf("索引:%d,值:%d\n", i, v)
         }
     }
     //循坏数组
     array := [5]int{1: 1, 3: 4}
     var array1 [5]int = array //success
     var array2 [4]int = array1 //error
     //必须是长度一样，并且每个元素的类型也一样的数组，才是同样类型的数组。

     //指针数组
     array := [5]*int{1: new(int), 3:new(int)}
     *array[1] = 1
     //给指针数组赋值
     //给没有分配地址的索引赋值，会提示无效指针
     array := [5]*int{1: new(int), 3:new(int)}
     array[0] =new(int)
     *array[0] = 2
     //要先分配地址才能赋值
     ```

  4. 函数间传数组：

     在函数传变量时，总是以值的方法，如果是数组的话，会直接复制整个数组传进去

     ```go
     func main() {
         array := [5]int{1: 2, 3:4}
         modify(&array)
         fmt.Println(array)
     }
     func modify(a *[5]int){
         a[1] =3
         fmt.Println(*a)
     }

     //传地址给这个函数是一个好方法，但要小心直接把数组修改了
     并且，数组的指针和指针数组是两个概念，数组的指针是*[5]int,而指针数组是[5]*int,*的位置是不一样的
     ```

- **切片**

  1. 内部实现:基于数组实现的，本身很小，底层是连续分配的，效率很高，可以使用索引，可以迭代以及垃圾回收优化

  2. 声明和初始化：

     ```go
     slice := []int{1, 2, 3, 4, 5}
     slice1 := slice[:]
     slice2 := slice[0:]
     slice3 := slice[:5]slice := []int{1, 2, 3, 4, 5}
     slice1 := slice[:]
     slice2 := slice[0:]
     slice3 := slice[:5]

     //并且，新的切片和原来的切片共用一个底层数组，当修改的时候，底层数组的值就会改变，原切片和新切片也会改变

     slice:=make([]int,5)
     //指定容量和长度为5的切片
     slice:=make([]int,5,10)
     //这时，我们创建的切片长度时5，容量时10,需要注意的这个容量10其实对应的是切片底层数组的。
     //因为切片的底层是数组，所以创建切片时，如果不指定字面值的话，默认值就是数组的元素的零值。这里我们所以指定了容量是10，但是我们职能访问5个元素，因为切片的长度是5，剩下的5个元素，需要切片扩充后才可以访问。
     //容量必须>=长度，我们是不能创建长度大于容量的切片的

     slice:=[]int{1,2,3,4,5}
     //是使用字面量，就是指定初始化的值。
     slice:=[]int{4:1}
     //指定了第五个元素为1，其他元素都是默认值
     //切片还有nil切片和空切片，它们的长度和容量都是0，但是它们指向底层数组的指针不一样，nil切片意味着指向底层数组的指针为nil，而空切片对应的指针是个地址。
     nil切片表示不存在的切片，而空切片表示一个空集合，他们各有用处

     //基于现有的数组和切片创建
     slice := []int{1, 2, 3, 4, 5}
     slice1 := slice[:]
     slice2 := slice[0:]
     slice3 := slice[:5]

     //并且，新的切片和原来的切片共用一个底层数组，当修改的时候，底层数组的值就会改变，原切片和新切片也会改变

     //新切片的长度和容量
     对于底层数组容量是k的切片slice[i:j]来说
     长度：j-i
     容量:k-i

     //此外还有一种3个索引的方法，第3个用来限定新切片的容量，其用法为slice[i:j:k]。

     slice := []int{1, 2, 3, 4, 5}
     newSlice := slice[1:2:3]
     ```

  3. 使用切片：

     切片只能访问到其长度内的元素，访问超过长度外的元素，会导致运行时异常，与切片容量关联的元素只能用于切片增长。

     我们使用内置`append`函数即可。`append`函数可以为一个切片追加一个元素，至于如何增加、返回的是原切片还是一个新切片、长度和容量如何改变这些细节，`append`函数都会帮我们自动处理

     > newSlice=append(newSlice,10)
     >
     > ![image.png](https://s2.loli.net/2025/03/27/kTrG9EAKNHaXxI7.png)

  4. 迭代切片：用for ranage遍历

  5. 我们知道切片是3个字段构成的结构类型，所以在函数间以值的方式传递的时候，占用的内存非常小，成本很低。在传递复制切片的时候，其底层数组不会被复制，也不会受影响，复制只是复制的切片本身，不涉及底层数组

     在函数间传递切片非常高效，而且不需要传递指针和处理复杂的语法，只要复制切片，所以函数间传递参数，多传递切片，而不是数组
     ```

     ```



- **map**

  map就是映射

  Map是一种数据结构，是一个集合，用于存储一系列无序的键值对。它基于键存储的，键就像一个索引一样，这也是Map强大的地方，可以快速快速检索数据，键指向与该键关联的值。

  使用hash表可以实现map

  ####  声明和初始化

  ```go
  dict:=make(map[string]int)
  dict["张三"] = 43
  //键类型是string，值是int的map
  //等同于
  dict := map[string]int{"张三":43}
  dict := map[string]int{}
  //不使用make创建就要加上一个大括号
  var dict map[string]int
  //创建一个nil的map类型，不会进行内存分配

  ```

  ####  使用map

  > age,exists := dict["李四"]
  >
  > 返回值和是否遵从的boolen变量
  >
  > delete(dict,"张三")
  >
  > 删除任何不存在的键也是可以的,只是没有任何效果
  >
  > 使用range遍历map,得到的值是对应的键和值

  把map传递给一个函数,不会创建副本,也就是说,这个函数对map的操作,都会被外部的map感知





####  go类型

Go 语言是一种静态类型的编程语言，所以在编译器进行编译的时候，就要知道每个值的类型，这样编译器就知道要为这个值分配多少内存，并且知道这段分配的内存表示什么。

提前知道值的类型的好处有很多，比如编译器可以合理的使用这些值，可以进一步优化代码，提高执行的效率，减少bug等等。

- 基本类型

  就是Go语言自带的类型,不可改变的原始类型

  操作基本类型定义的数据都是传递了一个副本,这样避免了在多线程里创建新的值是安全的

- 引用类型

  像切片\map\接口\函数以及chan

  ![74909573010](C:\Users\zxh\Desktop\前端\go基础\go文档分析.assets\1749095730102.png)

  ​

- 结构类型：

  就是一个结构体，通过type关键字和struct关键字声明

  除了基本的原始类型外，结构体内的值也可以是引用类型，或者自己定义的其他类型。具体选择类型，要根据实际情况，比如是否允许修改值本身，如果允许的话，可以选择引用类型，如果不允许的话，则需要使用基本类型。

  ![74944679355](C:\Users\zxh\Desktop\前端\go基础\go文档分析.assets\1749446793557.png)

  ​















