# 微服务框架 

- **小案例：**

  > 安装：![74306054796](C:\Users\zxh\Desktop\前端\go基础\框架基础.assets\1743060547962.png)
  >
  > main.go是go程序的入口文件，以包为管理单位，用package声明，每个源文件都要声明一个所属的包

- gin：安装和使用

  ```go
  func main{
      r:=gin.Default()
      
      r.Get('/hello',func(c *gin.Context)){
          c.String{http.StatusDk,"hello world"}
      }
      
      r.Run(":9999")
  }
  ```

- gorm：数据库链接

- linux部署

  ​

  ​

  ​

  ​

- go架构：**kratos架构**

  ```
  ├─api         # protobuf 定义
  │  └─helloworld
  │      └─v1
  ├─cmd
  │  └─server       # 命令启动入口
  ├─configs              # 程序启动配置
  ├─internal
  │  ├─biz        # 内部领域服务存放地址
  │  ├─conf        # 配置文件解析地址
  │  ├─data        # 业务数据访问，包含 cache、db 等封装，实现了 biz 的 repo 接口
  │  ├─server       # 对外服务创建地址
  │  └─service      # API接口服务层
  └─third_party               
      ├─errors
      ├─google
      │  ├─api
      │  └─protobuf
      │      └─compiler
      ├─openapi
      │  └─v3
      └─validate
  ```

  ![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/160a49a6f0c14b0da1363a614f73556c~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=857&h=330&s=29136&e=png&b=fdfdfd)

  > 核心是biz这个东西：
  >
  > 1. 在领域服务内部，统一都使用领域对象来进行传递。如：service调用biz中的方法，对象从v1.api --> domain。 领域服务调用data进行数据的存储时，将domain--> repo对象。
  > 2. 减少项目中全局对象的传递，使用依赖注入原则。（是减少不是一定不）

  ```
  |---api 
  |     |---controller  # 控制器
  |     |---reply  # 响应对象
  |     |---request  # 请求对象
  |     |---router  # 路由
  |---common  
  |     |---app     # 分页和接口响应处理
  |     |---enum    # 枚举
  |     |---errcode # 项目错误管理
  |     |---logger  # 项目的日志门面
  |     |---middleware  # 中间件
  |     |---util  # 辅助函数
  |---config	# 配置
  |---dal    # 数据访问层
  |     |---cache    # 缓存
  |     |---dao    # 数据访问对象
  |     |---model    # 数据模型对象
  |---event
  |---library
  |---logic    # 逻辑层
  |     |---appservice    # 应用服务
  |     |---domainservice # 领域服务
  |     |---do # 领域对象    
  |---resources	# 资源目录
  |---test	# 测试脚本
  ```

  ![img](https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/39195114ba434754b7c2f0f71de0da59~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAga2V2aW55YW4=:q75.awebp?rk3s=f64ab15b&x-expires=1743359999&x-signature=81tgAzGANpW8bdsAtQro8ZCNVGQ%3D)

  ​

  ​

  ​

  ## 其他架构：go-zero

- go-zero整体上做为一个稍重的微服务框架，提供了微服务框架需要具备的通用能力，同时也只带一部分的强约束，例如针对web和rpc服务需要按照其定义的DSL的协议格式进行定义，日志配置、服务配置、apm配置等都要按照框架定义的最佳实践来走。社区建设： go-zero已经是CNCF项目，做为一个后起的微服务框架，不得不说在国内社区生态建设和维护上，完美适配国内开源的现状，在微信群、公众号、各种大会等多渠道进行推广，社区也时常有文章指导实践。

- **安装：**

  ```bash
  # Go 1.15 及之前版本
  go get -u github.com/zeromicro/go-zero/tools/goctl@latest

  # Go 1.16 及以后版本
  go install github.com/zeromicro/go-zero/tools/goctl@latest

  $ goctl -v
  goctl version 1.5.1 darwin/amd64

  ```

  - 最终在我们的￥GOBIN目录下会有下面几个文件

    ![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e09f40f3d3f9433e830725cf5f09ab71~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)

- **http服务代码示例：**

  - 开启go modules `GOPROXY=https://goproxy.cn,direct`

  ![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f7cd0ae7db884173a47cf3a8a358ad74~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)

- **微服务示例：**

  我们创建一个目录`zero-order`，并在目录下新建一个order.api

  我们要使用goctl构建一个单体应用，比如一个订单服务

  先创建一个目录，在目录下新建order.api

  ```less
  $ touch order.api
  $ cat order.api
  // api语法版本
  syntax = "v2"

  info(
  author: "技术小虫"
  date: "2023-04-21"
  desc: "订单api说明"
  )

  type (
  OrderInfoReq {
  OrderId int64 `json:"order_id"`
  }
  OrderInfoResp {
  OrderId int64 `json:"order_id"` //订单id
  GoodsName string `json:"goods_name"`  //商品名称
  }
  )
  //定义了一个服务叫order-api
  service order-api {
  //获取接口的名字叫获取用户信息
  @doc "获取订单信息"
  //对应的hanlder即controller是orderInfo
  @handler orderInfo
  //请求方法是post，路径是/order/order_id，参数是OrderInfoReq，返回值是OrderInfoResp
  post /order/info (OrderInfoReq) returns (OrderInfoResp)
  //可以继续定义多个api
  }



  //使用goctl生成具体的api代码
  # 根据当前目录下的api文件在当前目录生成api项目，
  $ goctl api go -api *.api -dir ./  --style=goZero
  Done.

  ```

  ![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/abbb2aa56d7d46d5ac4d8862cc406da4~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)

  > 可以在logic->orderInfoLogic去追踪到你要修改的那部分代码

  >  其中yaml文件定义了启动的端口号和ip，handler的routes.go 定义的路由。使用`go run order.go -f etc/order-api.yaml `启动服务，使用默认端口8888。请求oder/info接口。一个简单的api服务完成了。

  ​

- **rpc服务:**

  上面创建的单体服务没有服务间的通讯,微服务中api服务会多一些rpc调用的配置

  ​

  说明：如无 `cd` 改变目录的操作，所有操作均在 `go-zero-demo` 目录执行

  ```go
  //创建user rpc服务
  $ mkdir -p mall/user/rpc

  //添加user.proto文件,增加getUser方法
  $ vim mall/user/rpc/user.proto



  //在这个文件增加这些代码
  syntax = "proto3";
  package user;

  // protoc-gen-go 版本大于1.4.0, proto文件需要加上go_package,否则无法生成
  option go_package = "./user";
  message IdRequest {
      string id = 1;
  }
  message UserResponse {
      // 用户id
      string id = 1;
      // 用户名称
      string name = 2;
      // 用户性别
      string gender = 3;
  }
  service User {
      rpc getUser(IdRequest) returns(UserResponse);
  }

  ```

  ​

  - 如未安装 `protoc`，请参考 <https://github.com/protocolbuffers/protobuf/releases> 自行安装。

  -  如未安装 `protoc-gen-go`，请参考 <https://grpc.io/docs/languages/go/quickstart/> 自行安装。

    > 注意：旧版本的 `protoc-gen-go` 不支持 `--go-grpc_out`

    ```
     $ cd mall/user/rpc
     $ goctl rpc protoc user.proto --go_out=./types --go-grpc_out=./types --zrpc_out=.Done.

    ```

  ​

  - 再去填充业务逻辑

  ​

- **创建 order  api服务:**

  ```
  # 回到 go-zero-demo/mall 目录$ mkdir -p order/api && cd order/api
  ```

  - 添加api文件

    ```
    $ vim order.api
    ```

    ```go
    type(
        OrderReq {
            Id string `path:"id"`
        }
        OrderReply {
            Id string `json:"id"`
            Name string `json:"name"`
        }
    )
    service order {
        @handler getOrder
        get /api/order/get/:id (OrderReq) returns (OrderReply)
    }
    ```

  - 生成order服务

    ```
    $ goctl api go -api order.api -dir .Done.
    ```

  - 添加user rpc配置

    ```
    $ vim internal/config/config.go
    ```

    ```go
    package config
    import (
        "github.com/zeromicro/go-zero/zrpc"
        "github.com/zeromicro/go-zero/rest"
    )
    type Config struct {
        rest.RestConf
        UserRpc zrpc.RpcClientConf
    }
    ```

  - 添加yaml配置

    ```
    $ vim etc/order.yaml
    ```

    ```go
    Name: order
    Host: 0.0.0.0
    Port: 8888
    UserRpc:
      Etcd:
        Hosts:
        - 127.0.0.1:2379
        Key: user.rpc
    ```

  - 完善服务依赖

    ```
    $ vim internal/svc/servicecontext.go
    ```

    ```go
    package svc
    import (
        "go-zero-demo/mall/order/api/internal/config"
        "go-zero-demo/mall/user/rpc/user"
        "github.com/zeromicro/go-zero/zrpc"
    )
    type ServiceContext struct {
        Config  config.Config
        UserRpc user.User
    }
    func NewServiceContext(c config.Config) *ServiceContext {
        return &ServiceContext{
            Config:  c,
            UserRpc: user.NewUser(zrpc.MustNewClient(c.UserRpc)),
        }
    }
    ```

  - 添加order演示逻辑

    给 `getorderlogic` 添加业务逻辑

    ```
    $ vim internal/logic/getorderlogic.go
    ```

    ```go
    package logic
    import (
        "context"
        "errors"
        "go-zero-demo/mall/order/api/internal/svc"
        "go-zero-demo/mall/order/api/internal/types"
        "go-zero-demo/mall/user/rpc/types/user"
        "github.com/zeromicro/go-zero/core/logx"
    )
    type GetOrderLogic struct {
        logx.Logger
        ctx    context.Context
        svcCtx *svc.ServiceContext
    }
    func NewGetOrderLogic(ctx context.Context, svcCtx *svc.ServiceContext) GetOrderLogic {
        return GetOrderLogic{
            Logger: logx.WithContext(ctx),
            ctx:    ctx,
            svcCtx: svcCtx,
        }
    }
    func (l *GetOrderLogic) GetOrder(req types.OrderReq) (*types.OrderReply, error) {
        user, err := l.svcCtx.UserRpc.GetUser(l.ctx, &user.IdRequest{
            Id: "1",
        })
        if err != nil {
            return nil, err
        }
        if user.Name != "test" {
            return nil, errors.New("用户不存在")
        }
        return &types.OrderReply{
            Id:   req.Id,
            Name: "test order",
        }, nil
    }
    ```

  ## 启动服务并验证

  - 启动etcd

    ```
    $ etcd
    ```

  - 下载依赖

    ```
    # 在 go-zero-demo 目录下$ go mod tidy
    ```

  - 启动user rpc

    ```
    # 在 mall/user/rpc 目录
    $ go run user.go -f etc/user.yaml
    Starting rpc server at 127.0.0.1:8080...
    ```

  - 启动order api

    ```
    # 在 mall/order/api 目录
    $ go run order.go -f etc/order.yaml
    Starting server at 0.0.0.0:8888...
    ```

  - 访问order api

    ```
    $ curl -i -X GET http://localhost:8888/api/order/get/1
    HTTP/1.1 200 OK
    Content-Type: application/json
    Date: Sun, 07 Feb 2021 03:45:05 GMT
    Content-Length: 30
    {"id":"1","name":"test order"}
    ```

  ​

  ​

  ​

  ​

  ​

  ​

  ​

  ​

  ​

  ​

  ​

  ​

  ​

  ​

  ​

  ​

  ​

  ​

  ​

  ​

  ​

  ​

  ​

  ​

  ​

  ​

  ​

  ​

  ​

  ​

  ​

  ​

  ​

  ​



























