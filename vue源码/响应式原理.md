# 数据响应

- **导论：**为了让面试的时候不是在说忽悠的话

- Object.defineProperty方法会直接再一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象

  ![74377875926](C:\Users\zxh\Desktop\前端\vue源码\响应式原理.assets\1743778759269.png)

  a不发生改变，可以固定属性 ，类似的还有：

  enumerable：false  //不可被枚举（遍历）

- ![74377939628](C:\Users\zxh\Desktop\前端\vue源码\响应式原理.assets\1743779396282.png)

  访问这个键，就会除法get，更新就触发set，这种就是侵入式的方法

#### defineReactive

把OBject.defineProperty封装起来,利用函数的闭包,让这个东西更好的使用

```javascript
//main文件
var obj={}
function defineReactive(data,key,val){
    const dep =new Dep(  )
    //构建闭包环境
    if(arguments.length==2){
        val=data[key]
    }
    //子元素要进行observe,至此形成了递归.这个递归不是函数自己调自己,而是多个函数循环调用
    let childOb=observe(val)
    
    Object.defineProperty(data,key,{
        enumerable:true
        //可以枚举的 
        configurable:true
        //可以被配置
        get(){
        return val
    }//访问
        set(old,new){
        if(val==new){
           return
           }else{
           val=new
           childOb=observe(val)
            //新值也要观察
           }
           return val
    }//更新
        //val是一个中间变量,get返回`val,set让val等于最新的值
        //替代了那个中间变量
    })
}
```

####  递归侦测对象的全部属性

创建一个Observer的类,保证一个正常的object转换为每个层级都是响应式的结构

```javascript
//在Obeserver.js文件中
function def (obj,key,value,enuertable){
    Objecct.defineProperty(obj,key,{
        value,
        enuerable,
        writable:true,
        configurable:true
    })
}

export default class Observer{
    constructor(value){
        //给示例(this,一定要注意,构造函数中的this不是表示类本身,而是添加实例)
        def(value,"__ob__",this,false)
        //把每一个层级都转化为可以响应的结构
        //这里要对数组做一个检测,是数组就要把数组原型指向arratMethods,用Object.setPrototypeOf(value,arrayMethods)去更改数组的原型
        //不是数组就最近调用walk方法 
    }
    
    walk(value){
        //遍历
        for(let k in value){
            defineReactive(value,k)
        }
    }
    
    
    //数组的特殊遍历
    observeArray(arr){
        for(let i= 0;i=arr.length;i<1;i++){
            observe(arr[i])
        }
    }
}
```

```javascript
//在observe.js中,创建observe函数
function Observe(value){
    this.dep=new Dep()
    //给每一层都加上一个dep属性
    //看obj身上有没有__ob__ 
    if(typeof value!="object")return
    var ob
    if(typeof value.__ob__!="undefine"){
        ob=value.__ob__
    }else{
        ob=new Observer(value)
    }
    return ob
}
```

![74392278702](C:\Users\zxh\Desktop\前端\vue源码\响应式原理.assets\1743922787026.png)



####  数组的响应式处理

vue改写了push、pop、shift、unshift、splice、sort、reverse这些方法

```javascript
//得到Array.prototype
const arrayPrototype=Array.prototype;
//以array.prototype为原型创建arrayMethods对象
const arrayMethods=Object.create(arrayPrototype);
//改写7个方法
const methodsNeedChange=[
    'push','pop','shift','unshift','splice','sort','reverse'
];


methodsNeedChange.forEach(methodName=>{
    //备份原来的方法,原来的函数的功能不能少
    const original=arrayPrototypr[methodName];
    //定义新的方法
    def(arrayMethods,methodName,function(){
        const result= original.apply(this,arguments);
        const args =[...arguments];
        
            //把这个数组身上的__ob__去出来,__ob__已经被添加了,为什么已经被添加了?因为数组肯定不是最高层,比如obj.g属性是数组,obj不能是数组,第一次遍历obj这个对象的第一层的时候,已经给g属性(就算这个数组)添加了__ob__属性
        const ob=this.__ob__;
        //有三种方法push\unshift\splice能够插入新项,现在要把插入的新项也要变为observe的
        let inserted=[]
        
        switch(methodName){
                case:'push'
                case:'unshift':
                     inserted=args
                case'splice':
                     inserted=args.slice(2);
                     break
        }
        //判断有没有要插入的新项
        if(inserted){
            ob.observeArray(inserted)
        }
        
        const result= original.apply(this,arguments)
        //恢复了原来的功能
        return result
    },false)
})
```



- 依赖收集

  需要用到数据的地方，称为依赖

  vue1.x，细颗粒度依赖，用到数据的DOM都是依赖

  vue2.x，中颗粒度依赖，用到数据的组件是依赖

  在getter中手机依赖，在setter中触发依赖

  ![74453243748](C:\Users\zxh\Desktop\前端\vue源码\响应式原理.assets\1744532437485.png)

  ![74453265753](C:\Users\zxh\Desktop\前端\vue源码\响应式原理.assets\1744532657532.png)

  ```javascript
  //创建一个新的dep.js
  export default class Dep{
      construct(){
          //
      }
      
      notify(){
          //
      }
  }

  //创建一个watcher.js
  export default class Watcher{
      construct(){
          //
      }
  }
  ```

  ​











