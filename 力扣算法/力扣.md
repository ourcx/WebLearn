# 力扣

![74442561504](C:\Users\zxh\Desktop\前端\力扣算法\力扣.assets\1744425615040.png)

数据结构：计算机存储或者组织数据的方式

算法：解决问题的方式 ，不同于去重这种逻辑，去重不是算法



####  时间复杂度

执行算法花费的时间

了解代码的快慢

表示：大O表示法：O(1),O(n),O(n^2)



####  空间复杂度

算法执行需要占用的空间,也是大O表示法

 

###  例题

####  栈

- 力扣20题

  ![74611676745](C:\Users\zxh\Desktop\前端\力扣算法\力扣.assets\1746116767457.png)

  ```javascript
  /**
   * @param {string} s
   * @return {boolean}
   */
  var isValid = function(s) {
      
      var stack = [];
      for(let i = 0;i<s.length;i++){
          const start = s[i];
          if(s[i]=='('||s[i]=='{'||s[i]=='['){
              stack.push(s[i])
              //入栈
          }else{
              const end = stack[stack.length-1];
              if(start==')'&&end=='('||start=='}'&&end=='{'||start==']'&&end=='['){
                  stack.pop()
              }else{
                  return false;
              }
          }
      }
      return stack.length==0
  };
  ```

  ​

- 力扣1047

  ![74633977637](C:\Users\zxh\Desktop\前端\力扣算法\力扣.assets\1746339776370.png)

  ```javascript
  var removeDuplicates = function (s) {
      let stack = [];
      for(v of s){
          let prev = stack.pop();
          if(prev!=v){
              stack,push(prev)
          }
      }
  }
      var arr = [];
      var index = 0

      while (index <= s.length) {
          if (arr[arr.length - 1] == s[index]) {
              arr.pop()
              index += 1
          }
          else if (arr[arr.length - 1] != s[index]) {
              arr.push(s[index])
              index += 1
          }
      }

      return arr.join("")
  }
  //我的写法 
  ```



  var removeDuplicates = function (s) {
      let stack = [];
      for(v of s){
          let prev = stack.pop();
          //先拉出来，不一样放回去，一样就不管了
          if(prev!=v){
              stack,push(prev);
              stack.push(v);
  }
          return stack.join("")
          
  }
      
  }


  ```

  ​

- 力扣71

  ![74634253995](C:\Users\zxh\Desktop\前端\力扣算法\力扣.assets\1746342539957.png)

  ```javascript
  var simplifyPath = function (path) {
    let stack=[];
      let str='';
      let arr = path.split('/');
      arr.forEach(val=>{
          if(val&&val==".."){
              stack.pop();
          }else if(val&&val!='.'){
              stack.push(val)
          }
      })
      arr.length?str="/"+stack.join('/'):str='/'
      
      return str
  };
  ```

  ​


####  队列

先进先出,后进后出

- 任务队列

   ![74634631374](C:\Users\zxh\Desktop\前端\力扣算法\力扣.assets\1746346313743.png)

  就是一个定时的打印和直接打印,它是先直接打印,然后才出现定时打印

  1. 执行:主线程读取js代码,此时同步环境,形容对应的堆和执行栈
  2. 主线程遇到异步任务,会推给异步线程执行处理
  3. 异步任务执行完成,将对应的异步任务推入任务队列
  4. 主线程查询任务队列,执行微任务,将其按照顺序执行,全部执行完毕
  5. 主线程查询任务队列,执行宏任务,取得第一个宏任务,执行
  6. 重复4\5步骤

  先执行同步,然后执行异步

  异步分为宏任务(定时器)和微任务(reomise.then),微任务里面也可能包含宏任务,这个宏任务会排到宏任务执行队列里面去

  这个执行过程是一个循环的是事件体系



#### 力扣933

写一个 `RecentCounter` 类来计算特定时间范围内最近的请求。

请你实现 `RecentCounter` 类：

- `RecentCounter()` 初始化计数器，请求数为 0 。
- `int ping(int t)` 在时间 `t` 添加一个新请求，其中 `t` 表示以毫秒为单位的某个时间，并返回过去 `3000` 毫秒内发生的所有请求数（包括新请求）。确切地说，返回在 `[t-3000, t]` 内发生的请求数。

**保证** 每次对 `ping` 的调用都使用比之前更大的 `t` 值。

```javascript
var RecentCounter = function() {
    this.stack=[]
};

/** 
 * @param {number} t
 * @return {number}
 */
RecentCounter.prototype.ping = function(t) {
    this.stack.push(t)
    while(this.stack[0]<t-3000){
        this.stack.shift()
    }
    return this.stack.length
};
```

其实就是队列最开始那个，小于了t-3000的时间后，就补计入数组里面了

题难读





####  链表

多个元素存储的列表

链表里面的元素在内存中不是按顺序存储的，而是通过next指针联系在一起的

 `js的原型链结构就是链表`



数组和链表的区别:

1. 数组:有序存储的,在中间某个位置删除或者添加某个元素
2. 链表:不是按照顺序的,而是通过next指针链接起来

![74883693758](C:\Users\zxh\Desktop\前端\力扣算法\力扣.assets\1748836937587.png)

![74883696816](C:\Users\zxh\Desktop\前端\力扣算法\力扣.assets\1748836968168.png)

- instanceof

  可以区分数据的类型

  原理:通过原型去查找

  ```javascript
  const instanceofs = (target,obj)=>{
      let p = target;
      while(p){
          if(p==obj.prototype){
              return true
          }
          p=p.__proto__
      }
  }
  ```


 环形链表

![74883889574](C:\Users\zxh\Desktop\前端\力扣算法\力扣.assets\1748838895744.png)

141检查环形链表



237私人题目描述

![74910834121](C:\Users\zxh\Desktop\前端\力扣算法\力扣.assets\1749108341212.png)

通过node.val=node.next.val变成

![74910837147](C:\Users\zxh\Desktop\前端\力扣算法\力扣.assets\1749108371474.png)

最后用node.next=node.next.next

![74910839756](C:\Users\zxh\Desktop\前端\力扣算法\力扣.assets\1749108397566.png)



87临时指针的使用

```javascript
var deleteDuplicates = function(head) {
    if(!head){
        return head
    }

    let cur = head
    //cur充当了临时指针,不改变head本身
    while (cur.next){
        if(cur.val==cur.next.val){
            cur.next=cur.next.next
        }else{
            cur=cur.next
        }
    }
    return head
};
```



206逆转链表

![74911037179](C:\Users\zxh\Desktop\前端\力扣算法\力扣.assets\1749110371792.png)

就是那一个prev从倒序开始存储,然后把它拼接上去,在重置curr为最开始存储的next



####  字典和哈希表



