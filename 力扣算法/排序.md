 #  排序

![74988225766](C:\Users\zxh\Desktop\前端\力扣算法\排序.assets\1749882257669.png)

插帽龟它很稳

插帽龟喜欢选帽插，插完就慌了（方了，时间复杂度是n^2）



#### 排序稳定性

稳定性是排序算法的一个重要性质，我们可以简单总结为：

**对于序列中的相同元素，如果排序之后它们的相对位置没有发生改变，则称该排序算法为「稳定排序」，反之则为「不稳定排序」**。

如果单单排序 int 数组，那么稳定性没有什么意义。但如果排序一些结构比较复杂的数据，那么稳定排序就会有一定的优势。

比如说现在你有若干订单数据，已经按照交易日期排好序了，现在你想对用户 ID 再进行排序，这样一来相同用户 ID 的订单就会聚集在一起，方便查看。稳定排序和不稳定排序的区别就体现在这里：

**如果你用稳定排序算法**，那么排序完成后，相同用户 ID 的订单依然会按照交易日期有序排列：

```text
   Date    UserID
2020-02-01  1001
2020-02-02  1001
2020-02-03  1001

2020-01-01  1002
2020-01-02  1002
2020-01-03  1002
...
```

因为之前已经按照日期排好序了，对用户 ID 稳定排序之后，相同用户 ID 的订单的相对位置保持不变，所以在日期上依然是有序的。



####  原地排序

![75055065237](C:\Users\zxh\Desktop\前端\力扣算法\排序.assets\1750550652372.png)

不在于是否返回新的数组

####  选择排序

非稳定排序

先遍历一遍数组，找到数组中的最小值，然后把它和数组的第一个元素交换位置；接着再遍历一遍数组，找到第二小的元素，和数组的第二个元素交换位置；以此类推，直到整个数组有序。





- 选择排序的稳定算法

  **所以优化的方向就在这里，你不要图省事儿直接把 nums[sortedIndex] 交换到 nums[minIndex]，而是模仿 在数组中部插入元素的操作**，将 `nums[sortedIndex..minIndex]` 的元素整体向后移动一位，把 `nums[sortedIndex + 1]` 的位置空出来让 `nums[sortedIndex]` 这个元素去那里待着。

  ```
  [2, 2', 2'', 1, 1']
   ^           ^
  [1, 2', 2'', _, 1']
   ^           ^
  [1, _, 2', 2'', 1']
   ^           ^
  [1, 2, 2', 2'', 1']
   ^           ^
  sortedIndex  minIndex
  ```

  可以看到，这次 `2, 2', 2''` 和 `1, 1'` 的相对顺序都没有发生改变，选择排序就变成了稳定排序了。

  ```javascript
  // 对选择排序进行第一波优化，获得了稳定性
  function sort(nums) {
      let n = nums.length;
      let sortedIndex = 0;
      while (sortedIndex < n) {
          // 在未排序部分中找到最小值 nums[minIndex]
          let minIndex = sortedIndex;
          for (let i = sortedIndex + 1; i < n; i++) {
              if (nums[i] < nums[minIndex]) {
                  minIndex = i;
              }
          }

          // 优化：将 nums[minIndex] 插入到 nums[sortedIndex] 的位置
          // 将 nums[sortedIndex..minIndex] 的元素整体向后移动一位
          let minVal = nums[minIndex];
          // 数组搬移数据的操作
          for (let i = minIndex; i > sortedIndex; i--) {
              nums[i] = nums[i - 1];
          }
          nums[sortedIndex] = minVal;

          sortedIndex++;
      }
  }
  ```

  ​



####  直接插入排序

![74988314011](C:\Users\zxh\Desktop\前端\力扣算法\排序.assets\1749883140119.png)

![74988316415](C:\Users\zxh\Desktop\前端\力扣算法\排序.assets\1749883164155.png)

指针后移一位,然后和前面的进行比较

```javascript
// 对选择排序进一步优化，向左侧有序数组中插入元素
// 这个算法有另一个名字，叫做插入排序
function sort(nums) {
    let n = nums.length;
    // 维护 [0, sortedIndex) 是有序数组
    let sortedIndex = 0;
    while (sortedIndex < n) {
        // 将 nums[sortedIndex] 插入到有序数组 [0, sortedIndex) 中
        for (let i = sortedIndex; i > 0; i--) {
            if (nums[i] < nums[i - 1]) {
                // swap(nums[i], nums[i - 1])
                let tmp = nums[i];
                nums[i] = nums[i - 1];
                nums[i - 1] = tmp;
            } else {
                break;
            }
        }
        sortedIndex++;
    }
}
```

这个算法的名字叫做**插入排序**，它的执行过程就像是打扑克牌时，将新抓到的牌插入到手中已经排好序的牌中。

插入排序的空间复杂度是 O(1)O(1)，是原地排序算法。时间复杂度是 O(n2)O(n2)，具体的操作次数和选择排序类似，是一个等差数列求和，大约是 n2/2n2/2 次。

插入排序是一种稳定排序，因为只有在 `nums[i] < nums[i - 1]` 的情况下才会交换元素，所以相同元素的相对位置不会发生改变。

## [初始有序度越高，效率越高](https://labuladong.online/algo/data-structure-basic/insertion-sort/#%E5%88%9D%E5%A7%8B%E6%9C%89%E5%BA%8F%E5%BA%A6%E8%B6%8A%E9%AB%98-%E6%95%88%E7%8E%87%E8%B6%8A%E9%AB%98)







####  希尔排序

![74988337228](C:\Users\zxh\Desktop\前端\力扣算法\排序.assets\1749883372285.png)

先确定一个步长

- 第一趟

  ![74988382153](C:\Users\zxh\Desktop\前端\力扣算法\排序.assets\1749883821538.png)

  子表不是连续存储的,只有逻辑上他们是线性的

- 第二躺

   步长是上一个的步长除以2![74988399790](C:\Users\zxh\Desktop\前端\力扣算法\排序.assets\1749883997902.png)

- 第三趟

  ![74988413658](C:\Users\zxh\Desktop\前端\力扣算法\排序.assets\1749884136583.png)

  这里还是直接插入的过程























####  冒泡排序

![74988417602](C:\Users\zxh\Desktop\前端\力扣算法\排序.assets\1749884176029.png)

把最小的冒出来

 ![74988443462](C:\Users\zxh\Desktop\前端\力扣算法\排序.assets\1749884434628.png)

 ```javascript
// 未优化的冒泡排序算法代码
function sort(nums) {
    let n = nums.length;
    let sortedIndex = 0;
    // @visualize bind nums[sortedIndex]
    while (sortedIndex < n) {
        let swapped = false
        // 寻找 nums[sortedIndex..] 中的最小值
        // 同时将这个最小值逐步移动到 nums[sortedIndex] 的位置
        for (let i = n - 1; i > sortedIndex; i--) {
            // @visualize color nums[i] #8ec7dd
            if (nums[i] < nums[i - 1]) {
                // swap(nums[i], nums[i - 1])
                [nums[i], nums[i - 1]] = [nums
                [i - 1], nums[i]];
                swapped=true
            }
        }
        // @visualize color *nums[sortedIndex] #7cd930
        if(!swapped){
            break
        }
        //提前终止算法
        sortedIndex++;
    }
}

let nums = [3, 1, 4, 1, 5, 9, 2, 6];
// @visualize shape nums rect
sort(nums);
 ```

冒泡排序是一个稳定排序





####  快速排序

![74988453117](C:\Users\zxh\Desktop\前端\力扣算法\排序.assets\1749884531173.png)

先选出一个轴

![74988519642](C:\Users\zxh\Desktop\前端\力扣算法\排序.assets\1749885196420.png)

再递归进行递归

![74988537023](C:\Users\zxh\Desktop\前端\力扣算法\排序.assets\1749885370236.png)

![75055489837](C:\Users\zxh\Desktop\前端\力扣算法\排序.assets\1750554898375.png)

把快速排列看成一个递归树

先排好一个,再去递归排序其他的





####  简单选择排序

![74988566678](C:\Users\zxh\Desktop\前端\力扣算法\排序.assets\1749885666787.png)

![74988576638](C:\Users\zxh\Desktop\前端\力扣算法\排序.assets\1749885766389.png)

找出最小的放在前面





####  堆排序

![74988579940](C:\Users\zxh\Desktop\前端\力扣算法\排序.assets\1749885799402.png)

建堆

![74988606889](C:\Users\zxh\Desktop\前端\力扣算法\排序.assets\1749886068894.png)

![74988646013](C:\Users\zxh\Desktop\前端\力扣算法\排序.assets\1749886460131.png)

![74988652131](C:\Users\zxh\Desktop\前端\力扣算法\排序.assets\1749886521314.png)

最后一个就是大根堆



找数

输出最大值

再恢复堆





####  归并排序

![74988703573](C:\Users\zxh\Desktop\前端\力扣算法\排序.assets\1749887035731.png)

把两个已经排序的数组,合并成一个有序的数组

左半边右半边排序

![75055518289](C:\Users\zxh\Desktop\前端\力扣算法\排序.assets\1750555182895.png)

这样再合并















