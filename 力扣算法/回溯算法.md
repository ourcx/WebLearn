####  回溯算法

不是一种很高效的算法，也是一种暴力算法，为了解决一些难以解决的问题

比如：组合问题，切割问题，子集问题，排列问题，棋盘问题，

回溯法可以被解析成一个n叉树

> void backting (参数){
>
> if(终止条件){}
>
> for(处理元素){
>
> 处理节点
>
> 递归
>
> 回溯操作,撤销节点操作
>
> }
>
> return 操作
>
> }

按照模板照猫画虎





####  组合，lk77

递归函数参数返回值

确定终止条件

单层递归逻辑

这个就是递归三部曲





这个搜索就是一路往下的过程，在这个树，去找到适合的条件

![75733314038](C:\Users\zxh\Desktop\前端\力扣算法\回溯算法.assets\1757333140383.png)

为什么是n-（k-path.length)+1

因为是至多从这里开始，就是path长度为0的时候，n=4，k=3的时候，最多从2开始，你能找到符合条件的内容，这样就完成了剪枝，后续的东西都是不符合的条件

这是最常见的剪枝方法，缩小范围

![75733352155](C:\Users\zxh\Desktop\前端\力扣算法\回溯算法.assets\1757333521552.png)

用结果倒推你的剪枝方法



####  剪枝

![75733232850](C:\Users\zxh\Desktop\前端\力扣算法\回溯算法.assets\1757332328509.png)

不剪枝的回溯算法会影响效率。。会搜索整个树型结构





####  子集问题

不是在终止条件的时候收集结果，而是在每层递归里面收集结果

去重的逻辑和上一个是一样的





####  递增子序列

所有回溯都是深度搜索

这个题主要在于标记重复的地方

很重要





组合：元素相同就是一个组合

排列：元素不同，顺序不同不是同一个





####  N皇后

![75818655057](C:\Users\zxh\Desktop\前端\力扣算法\回溯算法.assets\1758186550570.png)

3*3是无解的









####  贪心算法

局部最优得出全局最优，常识。。。或者很难的极端

没有套路，靠想，不要严格数学证明





