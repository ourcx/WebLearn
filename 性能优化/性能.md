#  性能

####  pail模型

RAIL 表示 Web 应用生命周期的四个不同方面：**响应（Response）**、**动画（Animation）**、**空闲（Idel）和加载（Load）**。由于用户对每种情境有不同的性能预期，因此，系统会根据情境以及关于用户如何看待延迟的用户体验调研来确定效果目标。

- 响应（Response）：在 50 毫秒内处理事件
- 动画（Animation）：在 10 毫秒内生成一帧
- 空闲（Idel）：最大限度地延长空闲时间
- 加载（Load）：提交内容并在 5 秒内实现互动



####  长任务优化

网页加载时，长时间任务可能会占用主线程，使页面无法响应用户输入（即使页面看起来已就绪）。点击和点按通常不起作用，因为尚未附加事件监听器、点击处理程序等。

基于前面介绍的 RAIL 模型，我们可以将超过 50 毫秒的任务称之为长任务，即：任何连续不间断的且主 UI 线程繁忙 50 毫秒及以上的时间区间。

实际上，Chrome 浏览器中的 Performance 面板也是如此定义的，我们录制一段 Performance，当主线程同步执行的任务超过 50 毫秒时，该任务块会被标记为红色。



长任务类型：

- 大型js代码加载
- 解析html和css
- dom查询/dom操作
- 运算量较大的js脚本执行

> 可以使用long tasks api来确定1哪些任务导致互动延迟

![74514813171](C:\Users\zxh\Desktop\前端\性能优化\性能.assets\1745148131716.png)

1. 串行任务的拆分

   ![img](https://github-imglib-1255459943.cos.ap-chengdu.myqcloud.com/the-savesettings-function-b71e8e42d8bf7_1440.png)

   实现异步就好了

   `setTimeOut`/`postTask`来实现,或者自己做任务管理器,管理串行任务执行,每执行一个任务后释放主线程

2. 单个超大任务拆分

   变成小任务

   1. 尽量将每个小任务拆成 50 毫秒左右的执行时间。
   2. 大任务分批执行，会由同步执行变为异步执行，需要考虑中间态（是否有新的任务插入，是否会重复执行）。



####  归纳篇

**常见优化方案：**

- 减少耗时：

  1. 网络请求优化。
  2. 首屏加载优化。
  3. 渲染过程优化。
  4. 计算/逻辑运行提速。

  ##### 网络请求优化

  网络请求优化的目标在于减少网络资源的请求和加载耗时，如果考虑 HTTP 请求过程，显然我们可以从几个角度来进行优化：

  1. 请求链路：DNS 查询、部署 CDN 节点、缓存等。
  2. 数据大小：代码大小、图片资源等。

  对于请求链路，核心的方案常常包括使用缓存，比如 DNS 缓存、CDN 缓存、HTTP 缓存、后台缓存等等，前端的话还可以考虑使用 Service Worker、PWA 等技术。使用缓存并非万能药，很多使用由于缓存的存在，我们在功能更新修复的时候还需要考虑缓存的情况。除此之外，还可以考虑使用 HTTP/2、HTTP/3 等提升资源请求速度，以及对多个请求进行合并，减少通信次数；对请求进行域名拆分，提升并发请求数量。

  数据大小则主要考对请求资源进行合理的拆分（CSS、Javascript 脚本、图片/音频/视频等）和压缩，减少请求资源的体积，比如使用 Tree-shaking、代码分割、移除用不上的依赖项等。

  在请求资源返回后，浏览器会进行解析和加载，这个过程会影响页面的可见时间，通过对首屏加载的优化，可有效地提升用户体验。

  #####  首屏加载优化

  首屏加载优化核心点在于两部分：

  1. 将页面内容尽快地展示给用户，减少页面白屏时间。
  2. 将用户可操作的时间尽量提前，避免用户无法操作的卡顿体验。

  减少白屏时间除了我们常说的首屏加载耗时优化，还可以考虑使用一些过渡的动画，让用户感知到页面正在顺利加载，从而避免用户对于白屏页面或是静止页面产生烦躁和困惑。除了技术侧的优化，很多时候产品策略的调整，给用户带来的体验优化效果不低于技术手段优化，因此我们也需要重视。

  整体的优化思路包括：尽可能提前页面可见，以及将用户可交互的时间提前。一般来说，我们需要尽可能地降低首屏需要的代码量和执行耗时，可以通过以下方式进行：

  - 对页面的内容进行分片/分屏加载
  - 仅加载需要的资源，通过异步或是懒加载的方式加载剩余资源
  - 使用骨架屏进行预渲染
  - 使用差异化服务，比如读写分离，对于不同场景按需加载所需要的模块
  - 使用服务端直出渲染，减少页面二次请求和渲染的耗时

  有些时候，我们的页面也需要在客户端进行展示，此时可充分利用客户端的优势：

  - 配合客户端进行资源预请求和预加载，比如使用预热 Web 容器
  - 配合客户端将资源和数据进行离线，可用于下一次页面的快速渲染
  - 使用秒看技术，通过生成预览图片的方式提前将页面内容提供给用户

  除了首屏渲染以外，用户在浏览器页面过程中，也会触发页面的二次运算和渲染，此时需要进行渲染过程的优化。

  ####  渲染优化

  渲染过程的优化要怎么定义呢？我们可以将其理解为首屏加载完成后，用户的操作交互触发的二次渲染。

  主要思路是减少用户的操作等待时间，以及通过将页面渲染帧率保持在 60FPS 左右，提升页面交互和渲染的流畅度。包括但不限于以下方案：

  - 使用资源预加载，提升空闲时间的资源利用率
  - 减少/合并 DOM 操作，减少浏览器渲染过程中的计算耗时
  - 使用离屏渲染，在页面不可见的地方提前进行渲染（比如 Canvas 离屏渲染）
  - 通过合理使用浏览器 GPU 能力，提升浏览器渲染效率（比如使用 css transform 代替 Canvas 缩放绘制）

  以上这些，是对常见的 Web 页面渲染优化方案。对于运算逻辑复杂、计算量较大的业务逻辑，我们还需要进行计算/逻辑运行的提速

  #####  计算/逻辑优化

  计算/逻辑运行速度优化的主要思路是“拆大为小、多路并行”，方式包括但不限于：

  - 通过将 Javscript 大任务进行拆解，结合异步任务的管理，避免出现长时间计算导致页面卡顿的情况
  - 将耗时长且非关键逻辑的计算拆离，比如使用 Web Worker
  - 通过使用运行效率更高的方式，减少计算耗时，比如使用 Webassembly
  - 通过将计算过程提前，减少计算等待时长，比如使用 AOT 技术
  - 通过使用更优的算法或是存储结构，提升计算效率，比如 VSCode 使用红黑树优化文本缓冲区的计算
  - 通过将计算结果缓存的方式，减少运算次数

- 减少资源占用

  - 合理使用缓存，不滥用用户的缓存资源（比如浏览器缓存、IndexDB），及时进行缓存清理
  - 避免存在内存泄露，比如尽量避免全局变量的使用、及时解除引用等
  - 避免复杂/异常的递归调用，导致调用栈的溢出
  - 通过使用数据结构享元的方式，减少对象的创建，从而减少内存占用










####  常见的页面加载流程

####  资源获取

一般来说，前端都会在打包的时候做资源大小的优化，资源类型包括 HTML、JavaScript、CSS、图片等。优化的方向包括：

#####  资源大小

(1) 合理的对资源进行分包。

首次渲染时只保留当前页面渲染需要的资源，将可以异步加载、延迟加载的资源拆离。通常我们会在代码编译打包的时候做处理，比如[使用 Webpack 将代码拆到不同的 bundle 包中 (opens new window)](https://webpack.docschina.org/guides/code-splitting/)。

(2) 移除不需要的代码。

我们项目中常常会引入许多开源代码，同时我们自己也会实现很多的工具方法，但是实际上并不是全部相关的代码都是最终需要执行的代码，所以我们可以在打包的时候移除不需要的代码。现在基本大多数的打包工具都提供了类似的能力，比如 Tree-shaking。

除此之外，如果我们的项目较大，使用和依赖了多个不同的仓库。如果在不同的代码仓库里，都依赖了同样的 npm 代码包，那么我们可能会遇到打包时引入多次同样的 npm 包的情况。一般来说，我们在管理依赖包的时候，可以使用`peerDependency`来进行管理，避免多次安装依赖、以及版本不一致导致的多次打包和安装等情况。

(3) 资源压缩和合并。

代码压缩也常常是在打包阶段进行的，包括 JavaScript 和 CSS 等代码，在一些情况下也可以使用图片合并（雪碧图的生成）。通常也是使用的打包工具以及插件自带的压缩能力，开启压缩后的代码可能比较难定位，可以配合 Sorce Mapping 来进行问题定位。

除了打包时的压缩，我们在页面加载的时候也可以启用 HTTP 的 gzip 压缩，可以减少资源 HTTP 请求的耗时。

##### 资源缓存

资源缓存的优化，其实更多时候跟我们的资源获取的链路有关，包括：

- 减少 DNS 查询时间，比如使用浏览器 DNS 缓存、计算机 DNS 缓存、服务器 DNS 缓存
- 合理地使用 CDN 资源，有效地减少网络请求耗时
- 对请求资源进行缓存，包括但不限于使用浏览器缓存、HTTP 缓存、后台缓存，比如使用 Service Worker、PWA 等技术

其实，我们观察资源获取的链路，获取除了大小和缓存的角度以外，还可以做更多的优化，比如：

- 使用 HTTP/2、HTTP/3，提升资源请求速度
- 对请求进行优化，比如对多个请求进行合并，减少通信次数
- 对请求进行域名拆分，提升并发请求数量





##### 资源加载

- 资源流程拆分
- 资源懒加载
- 资源预加载

(1) 页面可见。

页面可见可以分为部分可见以及内容完全可见。

对于部分可见，一般来说可以做 loading 的展示或是直出，让用户知道页面正在加载中，而非无响应。

对于内容完全可见，则是用户可视区域内的内容完全渲染完毕。除此之外，当前可视范围以外的内容，则可以拆离出首屏的分包，通过预加载或是懒加载的方式进行异步加载。

(2) 页面可交互。

同样的，页面可交互也可以分为部分可交互以及完全可交互。

一般来说，组件的样式渲染仅需要 HTML 和 CSS 加载完成即可，而组件的功能则可能需要加载具体的功能代码。对于复杂或是依赖资源较多的功能，加载的耗时可能相对较长。在这样的情况下，我们可以选择将该部分的资源做异步加载。

在初始的内容加载完毕之后，剩下的资源需要延迟加载。对于页面功能完全可交互，同样依赖于分包资源延迟加载。加载流程的优化，不管是页面可见，还是页面可交互，都离不开延迟加载。

延迟加载可分为两种方式进行加载：懒加载和预加载。因此，资源懒加载和预加载也是加载流程中很重要的一部分。

#####  懒加载

我们常说的懒加载其实又被称为按需加载，顾名思义就是需要用到的时候才会进行加载。通过将非必要功能进行懒加载的方式，可以有效地减少页面的初始加载速度，提升页面加载的性能。

常见的场景比如某些组件在渲染时不具备完整的功能，当用户点击的时候，才进行对应逻辑的获取和加载。遇到点击时未加载完成的情况下，可以通过适当的方式提示用户功能正在加载中。

资源懒加载常常也是跟资源分包一起进行，大多数前端框架（比如 Vue、React、Angular）也都提供了懒加载的能力，也可以[配合 Webpack 打包 (opens new window)](https://webpack.docschina.org/guides/lazy-loading/)做处理。

####  预加载

资源预加载也称为闲时加载，很多时候我们可以在页面空闲的时候，对一些用户可能会用到的资源做提前加载，以加快后续渲染或者操作的时间。

仔细一看，资源预加载和资源懒加载都比较相似，都会通过将资源拆离的方式做成异步延迟的方式加载。两者的区别在于：

- 懒加载的功能只会在需要的时候才进行加载，因为一些功能用户可能不会使用到，比如帮助中心、反馈功能等等
- 预加载的功能则是在不阻塞核心功能的时候，尽可能利用空闲的资源提前加载，这部分的功能则是用户很可能会使用到，比如获取下一屏页面的内容数据

##### 长耗时任务的拆离

如果我们的应用中会有耗时较长的计算任务，比如拉取回来的数据需要计算处理后才能渲染，**那么我们可以对这些耗时较长的任务做任务拆分。**

同样的，我们还是回到 Web 端加载 VsCode 的场景。假设我们在加载某个特别大的文件，则可以考虑分别对该文件的内容获取、数据转换做任务拆分**，比如分片获取该文件的内容，根据分片的内容做渲染的计算，计算过程如果耗时较长，也可以做异步任务的拆分，甚至可以结合 Web Worker 和 WebAssembly 等技术做更多的优化**

##### 读写分离

对于交互复杂、需要加载的资源较多的情况下，**如果用户的权限只是可读，那么对于编辑相关的功能可以做资源拆离，对于有权限的用户才进行编辑能力的加载。**

**读写分离其实属于资源拆分的一种具体场景**，我们可以结合业务的具体场景做具体的功能拆分，比如管理员权限相关的管理功能，也是类似的优化场景。











####  渲染篇





