####  http请求

![74400588837](C:\Users\zxh\Desktop\前端\ajax\交互.assets\1744005888373.png)

登录态

![74400611919](C:\Users\zxh\Desktop\前端\ajax\交互.assets\1744006119196.png)

定义接口 

![74400675927](C:\Users\zxh\Desktop\前端\ajax\交互.assets\1744006759273.png)

请求

![74400887136](C:\Users\zxh\Desktop\前端\ajax\交互.assets\1744008871366.png)























## 即时通讯

- **短轮询**：每隔一段时间发送一个请求即可，得到想要的结果，或者超出规定的最长时间就终止再发请求。

  ```javascript
  let count = 0;
  const timer = null;
  // 超时时间
  const MAX_TIME = 10 * 1000;
  // 心跳间隙
  const HEARTBEAT_INTERVAL = 1000; 

  /**
   * @description: 模拟请求后端数据 （第6次时返回true）
   */
  const fetchData = () => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        console.log('fetch data...', count)
        count += 1 
        if(count === 5) {
          resolve(true);
        }else {
          resolve(false);
        }
      }, 1000)
    });
  };

  /**
   * @description: 异步轮询，当超时时或者接口返回true时，中断轮询
   */
  const doSomething = async () => {
    try {
      let startTime = 0;
      const timer = setInterval(async ()=>{
        const res = await fetchData();
        startTime += HEARTBEAT_INTERVAL;
        if(res || startTime > MAX_TIME) {
          clearInterval(timer)
        }
      }, HEARTBEAT_INTERVAL)

    } catch (err) {
      console.log(err);
    }
  };

  doSomething();
  ```




  对服务器的资源消耗过大

- **长轮询：**

  长轮询的实现原理与轮询类似，只是客户端的请求会保持打开状态，直到服务器返回响应或超时。在服务器端，可以使用阻塞方式处理长轮询请求，即服务器线程会一直等待直到有新的数据或事件，然后返回响应给客户端。客户端收到响应后，可以处理数据或事件，并随后发送下一个长轮询请求。

  > 超时重新发请求,服务器响应重新发请求

  > 长轮询的实现多通过递归实现

  ![74401151460](C:\Users\zxh\Desktop\前端\ajax\交互.assets\1744011514600.png)

  优点:

  - 在无消息的情况下不会频繁请求,节省资源
  - 最好的兼容性,应用无状态
  - 开发方便,扩展方便

  适用:

  - 消息频率不高,并发量大且有可能弹性扩容场景,但实时要求极高的场景
  - 监控警报,重要事件.高并发大流量系统服务器实时推送

  ![74401193923](C:\Users\zxh\Desktop\前端\ajax\交互.assets\1744011939230.png)



- **sse:**

   sse是一种基于http的通信方式,只允许服务端向客户端通信,实现简单,浏览器原生支持,

  只能单向通讯,不支持二进制数据,只能utf-8编码消息



- **websocket:**

  ![74401213340](C:\Users\zxh\Desktop\前端\ajax\交互.assets\1744012133408.png)








####  ajax技术

核心是XMLHttpRequest对象，XHR为向都完全发送请求和解析服务器响应提供了接口，能够以异步的方式从服务器获取数据

```javascript
//创建一个xmlHttprequest实例对象
var xhr = new XMLHttpRequest();
 xhr.open('GET',
 'https://api.example.com/data',
 true) //这里稍微折叠一下方便大家看
//请求类型：最常用的两种类型是GET和POST。GET通常用于获取数据，而POST用于提交数据到服务器。
//请求URL：指定要请求的服务器资源地址。
//异步标志：设置为true，表示请求将是异步的，即JavaScript代码可以继续执行，不必等待服务器响应。
 xhr.send()
//发送请求

//处理响应和监听变化
xhr.onreadystatechange = function() {
    if (xhr.readyState === 4 && xhr.status === 200) {
        // 成功获取数据后的处理逻辑
        var data = JSON.parse(xhr.responseText); // 假设服务器返回的是JSON格式的数据
        console.log(data);
        updatePage(data); // 假设updatePage是一个处理数据并更新页面的函数
    } else if (xhr.readyState === 4 && xhr.status !== 200) {
        // 错误处理
        console.error('请求失败，状态码：' + xhr.status);
    }
};


```

**异步**：在发送请求后，JavaScript不会等待服务器响应，而是继续执行后续代码，当服务器响应到达时，通过事件回调处理响应。

**同步**：如果请求是同步的，则浏览器会暂停执行后续JavaScript，直到请求完成，这会导致页面冻结，用户体验极差，因此在AJAX中几乎总是使用异步模式。





####  axios二次封装:

`axios`是我们进行前端开发时常用的一种与后端接口交换数据的网络请求库。

axios是基于`promise`实现的，作用于node.js和浏览器中。在服务端它使用原生 node.js `http` 模块, 而在客户端 (浏览端) 则使用 `XMLHttpRequests`。

```javascript
// 向给定ID的用户发起请求  
axios.get('/user?ID=12345',{  
    params: {  //发送请求的数据
    ID: 12345  
    }  
})  
.then(function (response) {  
    // 处理成功情况  
    console.log(response);  
})  
.catch(function (error) {  
    // 处理错误情况  
    console.log(error);  
})  
.finally(function () {  
    // 总是会执行  
});

// 支持async/await用法  
async function getUser() {  
    try {  
        const response = await axios.get('/user?ID=12345');  
        console.log(response);  
    } catch (error) {  
        console.error(error);  
    }  
}
```

这个是原生的axios,过于不简化,不利于项目调用

二次封装就是为了方便

封装步骤大概是:

1. 创建axios实例:引入和封装

   ![74807145380](C:\Users\zxh\Desktop\前端\ajax\交互.assets\1748071453804.png)

2. 请求拦截:执行请求前的自定义回调,显示loading动画,取消请求,添加身份验证信息（前端的操作）

   ![74807173200](C:\Users\zxh\Desktop\前端\ajax\交互.assets\1748071732006.png)

3. 响应拦截，对于状态码的处理


一个接口可能在很多地方用到，所以要解耦

![74807234194](C:\Users\zxh\Desktop\前端\ajax\交互.assets\1748072341944.png)

封装好的，和api目录

![74807238667](C:\Users\zxh\Desktop\前端\ajax\交互.assets\1748072386676.png)

直接这样去使用，复用性高