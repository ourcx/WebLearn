# 浏览器底层原理

- **大致：**

  用户界面（导航栏等东西）、浏览器引擎（负责调度其他模块和核心）、渲染引擎（浏览器的层级关系，矢量图那些）、js引擎、网络（多线程的）、c++绘制模块、持久化存储器

  渲染引擎包含v8、html、css、布局、绘图渲染器=>会生成一些树

  还有视频、图片、音频解码器、合成库、图形库、网络库

- **内核分类：**

  ![image.png](https://s2.loli.net/2025/03/24/36ox47PDvuzlYdc.png)

- **每一个标签页都是一个子进程：**




#  大致渲染过程

1. 页面导航：输入url，浏览器进程进行请求和准备
2. 页面渲染：获得相关资源后，渲染器进程负责选项卡内部的渲染处理



####  -页面导航

前面我们介绍了一个 HTTP 的请求过程，该部分内容更倾向于将浏览器当成一个完整的对象，来介绍浏览器与外界的交互过程。

下面，我们来深入浏览器内部来进行分析，当用户在地址栏中输入内容时：

1. 首先浏览器进程的 UI 线程会进行处理：如果是 URI，则会发起网络请求来获取网站内容；如果不是，则进入搜索引擎。
2. 如果需要发起网络请求，请求过程由网络线程来完成。HTTP 请求响应如果是 HTML 文件，则将数据传递到渲染器进程；如果是其他文件则意味着这是下载请求，此时会将数据传递到下载管理器。
3. 如果请求响应为 HTML 内容，此时浏览器应导航到请求站点，网络线程便通知 UI 线程数据准备就绪。
4. 接下来，UI 线程会寻找一个渲染器进程来进行网页渲染。当数据和渲染器进程都准备好后，HTML 数据通过 IPC 从浏览器进程传递到渲染器进程中。
5. 渲染器进程接收 HTML 数据后，将开始加载资源并渲染页面。
6. 渲染器进程完成渲染后，通过 IPC 通知浏览器进程页面已加载。

以上是用户在地址栏输入网站地址，到页面开始渲染的整体过程。如果当前页面跳转到其他网站，浏览器将调用一个单独的渲染进程来处理新导航，同时保留当前渲染进程来处理像`unload`这类事件。

可以看到，页面导航的过程主要依赖浏览器进程。其中，上述过程中的步骤 5 便是页面的渲染部分，该过程同样依赖渲染器进程，我们一起来看看。

####  - 页面渲染

前面说过，渲染器进程负责选项卡内部发生的所有事情，它的核心工作是将 HTML、CSS 和 JavaScript 转换为可交互的页面。整体上，渲染器进程渲染页面的流程基本如下：

- 解析(Parser)：解析 HTML/CSS/JavaScript 代码
- 布局(Layout)：定位坐标和大小、是否换行、各种`position`/`overflow`/`z-index`属性等计算
- 绘制(Paint)：判断元素渲染层级顺序
- 光栅化(Raster)：将计算后的信息转换为屏幕上的像素



1. 渲染器进程的主进程会解析以下内容：

   解析html内容，产生一个dom节点树

   解析css，产生css规则树

   解析js脚本，解析完js才能继续解析html、

   解析完成就能得到dom节点树和css规则树，布局过程就算通过dom节点树和css规则树来构造渲染树

2. 布局：像header或者display：none的元素，它们会存在dom节点树中，但不会被添加到渲染树里

3. 绘制：在绘制步骤里，渲染器主线进程会遍历渲染树来创建绘制记录，渲染树发生变化，则渲染器会触发重排和重绘

   - 重绘：屏幕的一部分要重画，比如某个 CSS 的背景色变了，但是元素的几何尺寸没有变
   - 重排：元素的几何尺寸变了（渲染树的一部分或全部发生了变化），需要重新验证并计算渲染树

   为了不对每个小的变化都进行完整的布局计算，渲染器会将更改的元素和它的子元素进行脏位标记，表示该元素需要重新布局。其中，全局样式更改会触发全局布局，部分样式或元素更改会触发增量布局，增量布局是异步完成的，全局布局则会同步触发。

   重排需要涉及变更的所有的结点几何尺寸和位置，成本比重绘的成本高得多的多。所以我们要注意以避免频繁地进行增加、删除、修改 DOM 结点、移动 DOM 的位置、Resize 窗口、滚动等操作，因为可能会导致性能降低。



4. 光栅化：就算吧前面的东西转化为屏幕上的像素
















# 渲染技术底层

- **流程图：**

  ![image.png](https://s2.loli.net/2025/03/24/mMevJdDIw672aEB.png)

- **作用：**

  > dom树解析html文档，将html元素转化为dom节点
  >
  > css树将css对象封装起来，构建cssdom树
  >
  > 渲染树构建完成后，元素的位置关系以及需要应用的样式就确定了，这时浏览器会计算出所有元素的大小和绝对位置
  >
  > > 计算布局使用了：深度优先遍历算法
  >
  > 页面的绘制：在页面布局完成后，浏览器会将处理的结果，把每一个页面图床转换为像素，并对所有的媒体文件进行解码

- html树

  ​                             ![image.png](https://s2.loli.net/2025/03/27/vWyrlUPRawsoEzY.png)

  > 转化为Dom树的整体过程：
  >
  > html------》分词器-------》token流-------》栈------》Dom树
  >
  > ​
  >
  > 分词器：把html按节点来区分，分出不同的部分，注意自闭合和两个标签开始结尾的那种
  >
  > ​
  >
  > CSSOM 树和 DOM 树是独立的两个数据结构，它们并没有-一对应关系，浏览器在构建 DOM 树的同时，如果样式也加载完成了，那么 CSSOM 树也会同步构建。
  >
  > ​
  >
  > token流是将html的关键词进行分离，便利后续dom生成，降低复杂度

- **css**

  > 可继承的样式：不影响布局和尺寸，只影响外观
  >
  > 不可继承的样式:影响布局和尺寸，可以使用inherit强制继承。例外：font-size/line-herght
  >
  > ![74307218931](C:\Users\zxh\Desktop\前端\浏览器\浏览器的底层原理.assets\1743072189310.png)
  >
  > ![74307221116](C:\Users\zxh\Desktop\前端\浏览器\浏览器的底层原理.assets\1743072211163.png)
  >
  > 将样式和节点关联起来，形成指向











































